# üéØ DTOs with Prisma - Complete Guide

## üìã Table of Contents

1. [What are DTOs?](#what-are-dtos)
2. [Why Use DTOs with Prisma?](#why-use-dtos-with-prisma)
3. [Prisma Types vs DTOs](#prisma-types-vs-dtos)
4. [Types of DTOs](#types-of-dtos)
5. [Implementation Examples](#implementation-examples)
6. [Best Practices](#best-practices)

---

## What are DTOs?

**DTO** = **Data Transfer Object**

A DTO is a plain object that defines the shape of data being transferred between different layers of your application (usually between the client and server).

### Key Characteristics:

- Define the structure of input/output data
- Include validation rules
- Control what data is exposed to clients
- Separate API contracts from database models

---

## Why Use DTOs with Prisma?

### ‚ùå Without DTOs (Not Recommended)

```typescript
@Controller('users')
export class UsersController {
  @Post()
  create(@Body() body: any) {
    // ‚ö†Ô∏è No type safety!
    // No validation - anything can be sent
    return this.usersService.create(body);
  }
}
```

**Problems:**

- ‚ùå No input validation
- ‚ùå No type safety
- ‚ùå Security vulnerabilities (mass assignment)
- ‚ùå Poor API documentation
- ‚ùå Client doesn't know what to send

### ‚úÖ With DTOs (Recommended)

```typescript
// create-user.dto.ts
export class CreateUserDto {
  @IsEmail()
  @IsNotEmpty()
  email: string;

  @IsString()
  @MinLength(2)
  name: string;
}

@Controller('users')
export class UsersController {
  @Post()
  create(@Body() createUserDto: CreateUserDto) {
    // ‚úÖ Validated before reaching this point
    return this.usersService.create(createUserDto);
  }
}
```

**Benefits:**

- ‚úÖ Automatic validation
- ‚úÖ Type safety
- ‚úÖ Security (only allowed fields)
- ‚úÖ Self-documenting API
- ‚úÖ Better developer experience

---

## Prisma Types vs DTOs

### Prisma Generated Types

When you run `npx prisma generate`, Prisma creates TypeScript types:

```typescript
// Generated by Prisma (in node_modules/@prisma/client)
type User = {
  id: number; // Auto-generated
  email: string;
  name: string | null;
  password?: string; // Sensitive!
  createdAt: Date; // Auto-generated
  updatedAt: Date; // Auto-generated
};
```

**Purpose:** Represent your database schema exactly

**Problems for API:**

- Includes auto-generated fields (id, timestamps)
- Includes sensitive fields (password)
- Represents database structure, not API contract
- Can't add validation

### DTOs (Your Custom Types)

```typescript
// create-user.dto.ts
export class CreateUserDto {
  @IsEmail()
  email: string;

  @MinLength(8)
  password: string;

  @IsString()
  @IsOptional()
  name?: string;
}

// user-response.dto.ts
export class UserResponseDto {
  id: number;
  email: string;
  name?: string;
  createdAt: Date;

  // password is EXCLUDED for security
}
```

**Purpose:** Define API contracts with validation

---

## Types of DTOs

### 1. Create DTOs (Input)

Define what data is needed to create a resource.

```typescript
// src/users/dto/create-user.dto.ts
import { IsEmail, IsNotEmpty, IsString, MinLength } from 'class-validator';

export class CreateUserDto {
  @IsEmail({}, { message: 'Invalid email format' })
  @IsNotEmpty()
  email: string;

  @IsString()
  @MinLength(2)
  @IsOptional()
  name?: string;
}
```

**When to use:**

- POST endpoints
- Creating new records
- Required fields validation

### 2. Update DTOs (Input)

Define what data can be updated (usually all fields are optional).

```typescript
// src/users/dto/update-user.dto.ts
import { PartialType } from '@nestjs/mapped-types';
import { CreateUserDto } from './create-user.dto';

// Makes all fields from CreateUserDto optional
export class UpdateUserDto extends PartialType(CreateUserDto) {}

// Equivalent to:
// export class UpdateUserDto {
//   @IsEmail()
//   @IsOptional()
//   email?: string;
//
//   @IsString()
//   @MinLength(2)
//   @IsOptional()
//   name?: string;
// }
```

**When to use:**

- PATCH/PUT endpoints
- Updating existing records
- Partial updates

### 3. Response DTOs (Output)

Control what data is sent to clients.

```typescript
// src/users/dto/user-response.dto.ts
import { Exclude, Expose } from 'class-transformer';

export class UserResponseDto {
  @Expose()
  id: number;

  @Expose()
  email: string;

  @Expose()
  name?: string;

  @Expose()
  createdAt: Date;

  // Sensitive fields are excluded
  @Exclude()
  password: string;

  @Exclude()
  resetToken?: string;
}
```

**When to use:**

- GET endpoints
- Hiding sensitive data
- Formatting response data

### 4. Nested DTOs

For relationships (ONE-TO-ONE, ONE-TO-MANY, etc.).

```typescript
// src/users/dto/create-user-with-profile.dto.ts
import { ValidateNested, Type } from 'class-transformer';

class CreateProfileDto {
  @IsString()
  @MinLength(10)
  bio: string;

  @IsUrl()
  @IsOptional()
  website?: string;
}

export class CreateUserWithProfileDto {
  @IsEmail()
  email: string;

  @ValidateNested() // Validate nested object
  @Type(() => CreateProfileDto) // Transform to class instance
  profile: CreateProfileDto;
}
```

**When to use:**

- Creating entities with relationships
- ONE-TO-ONE relationships
- Nested data structures

---

## Implementation Examples

### Example 1: Basic CRUD with DTOs

```typescript
// 1. Create DTO
export class CreatePostDto {
  @IsString()
  @MinLength(5)
  title: string;

  @IsString()
  content: string;

  @IsInt()
  authorId: number;
}

// 2. Update DTO
export class UpdatePostDto extends PartialType(CreatePostDto) {}

// 3. Controller
@Controller('posts')
export class PostsController {
  @Post()
  create(@Body() createPostDto: CreatePostDto) {
    // Automatically validated!
    return this.postsService.create(createPostDto);
  }

  @Patch(':id')
  update(
    @Param('id', ParseIntPipe) id: number,
    @Body() updatePostDto: UpdatePostDto,
  ) {
    return this.postsService.update(id, updatePostDto);
  }
}

// 4. Service (uses Prisma types internally)
@Injectable()
export class PostsService {
  constructor(private prisma: PrismaService) {}

  create(createPostDto: CreatePostDto) {
    // DTO is converted to Prisma input
    return this.prisma.post.create({
      data: createPostDto,
    });
  }
}
```

### Example 2: ONE-TO-MANY with DTOs

```typescript
// Create post with categories (MANY-TO-MANY)
export class CreatePostWithCategoriesDto {
  @IsString()
  @MinLength(5)
  title: string;

  @IsString()
  content: string;

  @IsInt()
  authorId: number;

  @IsArray()
  @IsInt({ each: true })  // Validate each item in array
  categoryIds: number[];
}

// Controller
@Post('with-categories')
createWithCategories(@Body() dto: CreatePostWithCategoriesDto) {
  return this.postsService.createWithCategories(dto);
}

// Service
createWithCategories(dto: CreatePostWithCategoriesDto) {
  const { categoryIds, ...postData } = dto;

  return this.prisma.post.create({
    data: {
      ...postData,
      categories: {
        create: categoryIds.map(id => ({
          category: { connect: { id } }
        }))
      }
    },
    include: {
      categories: {
        include: {
          category: true
        }
      }
    }
  });
}
```

### Example 3: Response DTOs for Security

```typescript
// User entity (from Prisma - has password)
type User = {
  id: number;
  email: string;
  password: string;  // ‚ö†Ô∏è Sensitive!
  name: string;
  role: string;
}

// Response DTO (excludes password)
export class UserResponseDto {
  @Expose()
  id: number;

  @Expose()
  email: string;

  @Expose()
  name: string;

  @Expose()
  role: string;

  @Exclude()
  password: string;  // Won't be sent to client
}

// Controller
@Get(':id')
@UseInterceptors(ClassSerializerInterceptor)
async findOne(@Param('id') id: number): Promise<UserResponseDto> {
  const user = await this.usersService.findOne(id);
  return plainToClass(UserResponseDto, user, {
    excludeExtraneousValues: true
  });
}
```

---

## Best Practices

### 1. ‚úÖ DO: Separate Input and Output DTOs

```typescript
// Input (what clients send)
export class CreateUserDto {
  email: string;
  password: string;
  name?: string;
}

// Output (what clients receive)
export class UserResponseDto {
  id: number;
  email: string;
  name?: string;
  createdAt: Date;
  // password excluded!
}
```

### 2. ‚úÖ DO: Use PartialType for Update DTOs

```typescript
import { PartialType } from '@nestjs/mapped-types';

export class UpdateUserDto extends PartialType(CreateUserDto) {}
// All fields from CreateUserDto become optional
```

### 3. ‚úÖ DO: Add Meaningful Validation Messages

```typescript
export class CreateUserDto {
  @IsEmail({}, { message: 'Please provide a valid email address' })
  email: string;

  @MinLength(8, { message: 'Password must be at least 8 characters' })
  password: string;
}
```

### 4. ‚úÖ DO: Use Nested DTOs for Relationships

```typescript
export class CreateUserWithProfileDto {
  @IsEmail()
  email: string;

  @ValidateNested()
  @Type(() => CreateProfileDto)
  profile: CreateProfileDto; // Nested DTO
}
```

### 5. ‚ùå DON'T: Use Prisma Types Directly in Controllers

```typescript
// ‚ùå Bad
import { User } from '@prisma/client';

@Post()
create(@Body() user: User) {
  // Exposes all fields including auto-generated ones
}

// ‚úÖ Good
@Post()
create(@Body() createUserDto: CreateUserDto) {
  // Only accepts specified fields
}
```

### 6. ‚úÖ DO: Organize DTOs by Module

```
src/
  users/
    dto/
      create-user.dto.ts
      update-user.dto.ts
      user-response.dto.ts
      create-user-with-profile.dto.ts
      index.ts  (export all DTOs)
    users.controller.ts
    users.service.ts
    users.module.ts
```

### 7. ‚úÖ DO: Use index.ts for Clean Imports

```typescript
// src/users/dto/index.ts
export * from './create-user.dto';
export * from './update-user.dto';
export * from './user-response.dto';

// Now you can import like this:
import { CreateUserDto, UpdateUserDto } from './dto';
```

---

## Validation Rules Reference

### Common Validators

```typescript
import {
  IsString,
  IsInt,
  IsBoolean,
  IsEmail,
  IsUrl,
  IsArray,
  IsEnum,
  IsOptional,
  IsNotEmpty,
  MinLength,
  MaxLength,
  Min,
  Max,
  Matches,
  ValidateNested,
} from 'class-validator';

export class ExampleDto {
  // String validators
  @IsString()
  @MinLength(2)
  @MaxLength(50)
  name: string;

  // Email
  @IsEmail()
  email: string;

  // URL
  @IsUrl()
  website: string;

  // Number
  @IsInt()
  @Min(0)
  @Max(100)
  age: number;

  // Boolean
  @IsBoolean()
  isActive: boolean;

  // Array
  @IsArray()
  @IsString({ each: true }) // Each item must be string
  tags: string[];

  // Enum
  @IsEnum(['admin', 'user', 'guest'])
  role: string;

  // Optional
  @IsString()
  @IsOptional()
  bio?: string;

  // Required
  @IsNotEmpty()
  username: string;

  // Regex pattern
  @Matches(/^[a-zA-Z0-9_]+$/)
  slug: string;

  // Nested object
  @ValidateNested()
  @Type(() => AddressDto)
  address: AddressDto;
}
```

---

## Summary

### When to Use DTOs with Prisma

| Scenario            | Use DTO? | Why                   |
| ------------------- | -------- | --------------------- |
| Controller input    | ‚úÖ Yes   | Validation & security |
| Controller output   | ‚úÖ Yes   | Hide sensitive data   |
| Service layer       | ‚ùå No    | Use Prisma types      |
| Database operations | ‚ùå No    | Use Prisma types      |
| Internal functions  | ‚ùå No    | Use Prisma types      |

### The Flow

```
Client Request
    ‚Üì
DTO (validation) ‚Üê Controller
    ‚Üì
Service Layer (Prisma types)
    ‚Üì
Database (Prisma)
    ‚Üì
Service Layer (Prisma types)
    ‚Üì
DTO (filtering) ‚Üê Controller
    ‚Üì
Client Response
```

---

## Quick Checklist

- [ ] Install `class-validator` and `class-transformer`
- [ ] Create DTOs for each endpoint
- [ ] Add validation decorators
- [ ] Use DTOs in controllers
- [ ] Enable ValidationPipe in main.ts
- [ ] Test validation with invalid data
- [ ] Document validation rules
- [ ] Use response DTOs to hide sensitive data

---

## Testing DTOs

```typescript
// Example test
describe('CreateUserDto', () => {
  it('should validate email format', async () => {
    const dto = new CreateUserDto();
    dto.email = 'invalid-email';
    dto.name = 'John';

    const errors = await validate(dto);
    expect(errors.length).toBeGreaterThan(0);
    expect(errors[0].property).toBe('email');
  });

  it('should accept valid data', async () => {
    const dto = new CreateUserDto();
    dto.email = 'john@example.com';
    dto.name = 'John';

    const errors = await validate(dto);
    expect(errors.length).toBe(0);
  });
});
```

---

## Resources

- [class-validator documentation](https://github.com/typestack/class-validator)
- [class-transformer documentation](https://github.com/typestack/class-transformer)
- [NestJS Validation](https://docs.nestjs.com/techniques/validation)
- [Prisma Client API](https://www.prisma.io/docs/reference/api-reference/prisma-client-reference)

---

**Remember:** DTOs are your first line of defense against invalid data and security issues. Always use them in your controllers! üõ°Ô∏è
